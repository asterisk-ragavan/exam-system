<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taking Exam: {{ exam.name }}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { height: 100vh; overflow: hidden; display: flex; flex-direction: column; background-color: #f8f9fa; }
        #exam-header { height: 60px; background: #fff; border-bottom: 1px solid #ddd; display: flex; align-items: center; padding: 0 20px; justify-content: space-between; }
        #exam-container { flex: 1; display: flex; overflow: hidden; }
        #sidebar { width: 280px; background: #fff; border-right: 1px solid #ddd; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; }
        #main-content { flex: 1; padding: 40px; overflow-y: auto; display: flex; justify-content: center; }
        #question-area { max-width: 800px; width: 100%; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        
        .q-palette-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 10px; margin-top: 20px; }
        .q-btn { width: 100%; aspect-ratio: 1; border: 1px solid #ccc; background: #fff; border-radius: 4px; cursor: pointer; font-weight: bold; color: #555; }
        .q-btn.active { border-color: #0d6efd; background-color: #e7f1ff; color: #0d6efd; }
        .q-btn.answered { background-color: #198754; color: #fff; border-color: #198754; }
        .q-btn.marked { background-color: #ffc107; border-color: #ffc107; color: #000; }
        
        .timer-box { font-size: 1.5rem; font-weight: bold; font-family: monospace; color: #d9534f; }
        .option-label { display: block; padding: 10px 15px; border: 1px solid #dee2e6; border-radius: 6px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s; }
        .option-label:hover { background-color: #f8f9fa; }
        .option-input:checked + .option-label { background-color: #e7f1ff; border-color: #0d6efd; color: #0d6efd; font-weight: 500; }
        .option-input { display: none; }

        #connection-status { position: fixed; bottom: 10px; right: 10px; font-size: 0.8rem; opacity: 0.7; }
    </style>
</head>
<body>

    <!-- Header -->
    <div id="exam-header">
        <div>
            <h5 class="mb-0">{{ exam.name }}</h5>
            <small class="text-muted">{{ exam.course.code }}</small>
        </div>
        <div class="d-flex align-items-center">
            <div class="me-3 text-end">
                <small class="text-muted d-block">Time Remaining</small>
                <span id="timer" class="timer-box">--:--:--</span>
            </div>
            <button class="btn btn-danger" onclick="confirmSubmit()">Submit Exam</button>
        </div>
    </div>

    <!-- Main Body -->
    <div id="exam-container">
        <!-- Sidebar -->
        <div id="sidebar">
            <div class="mb-3">
                <strong>Student:</strong> {{ user.first_name }} {{ user.last_name }}<br>
                <small class="text-muted">{{ user.student_profile.roll_no }}</small>
            </div>
            <hr>
            <h6>Questions Palette</h6>
            <div class="q-palette-grid" id="palette">
                <!-- Generated by JS -->
            </div>
            <div class="mt-auto pt-3">
                <div class="d-flex align-items-center mb-2"><span class="badge bg-success me-2">&nbsp;</span> Answered</div>
                <div class="d-flex align-items-center mb-2"><span class="badge bg-secondary me-2">&nbsp;</span> Not Visited</div>
                <div class="d-flex align-items-center"><span class="badge bg-primary me-2">&nbsp;</span> Current</div>
            </div>
        </div>

        <!-- Question Area -->
        <div id="main-content">
            <div id="question-area">
                <div id="loading-spinner" class="text-center py-5">
                    <div class="spinner-border text-primary" role="status"></div>
                    <p class="mt-2">Loading Exam...</p>
                </div>

                <div id="question-content" style="display: none;">
                    <div class="d-flex justify-content-between mb-3">
                        <h5 id="q-number">Question 1</h5>
                        <span class="badge bg-light text-dark border" id="q-marks">1 Mark</span>
                    </div>
                    <p class="lead mb-4" id="q-text">Question text goes here...</p>
                    
                    <div id="options-container">
                        <!-- Options generated by JS -->
                    </div>

                    <div class="mt-4 d-flex justify-content-between">
                        <button class="btn btn-outline-secondary" id="btn-prev" onclick="navQuestion(-1)">Previous</button>
                        <button class="btn btn-primary px-4" id="btn-next" onclick="navQuestion(1)">Next</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="connection-status" class="text-success">● Connected</div>

    <!-- CSRF Token -->
    {% csrf_token %}

    <script>
        // --- Global State ---
        const EXAM_ID = {{ exam.id }};
        const API_BASE = '/api/exams';
        let attemptId = null;
        let questions = [];
        let currentQIndex = 0;
        let answers = {}; // { qId: { selected_options: [], answer_text: "" } }
        let remainingSeconds = 0;
        let timerInterval;
        let isDirty = false; // Has unsaved changes?

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            await startOrResumeExam();
            startTimer();
            renderPalette();
            loadQuestion(0);
            
            // Auto-save loop (every 10s if dirty)
            setInterval(() => {
                if (isDirty) saveCurrentAnswer();
            }, 10000);

            // Anti-cheating: Tab switch warning
            document.addEventListener("visibilitychange", () => {
                if (document.hidden) {
                    console.warn("Tab switched!");
                    // In production: Send log to server
                    alert("Warning: Please do not switch tabs during the exam.");
                }
            });
        });

        // --- Core Logic ---

        async function startOrResumeExam() {
            try {
                const response = await fetch(`${API_BASE}/start/${EXAM_ID}/`, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                        'Content-Type': 'application/json'
                    }
                });
                const data = await response.json();
                
                attemptId = data.attempt_id;
                questions = data.questions;
                remainingSeconds = Math.floor(data.remaining_seconds);
                
                // Restore answers
                if (data.saved_answers) {
                    answers = data.saved_answers;
                }

                document.getElementById('loading-spinner').style.display = 'none';
                document.getElementById('question-content').style.display = 'block';
            } catch (error) {
                alert("Failed to load exam. Please refresh.");
                console.error(error);
            }
        }

        function startTimer() {
            const timerEl = document.getElementById('timer');
            timerInterval = setInterval(() => {
                if (remainingSeconds <= 0) {
                    clearInterval(timerInterval);
                    submitExam(true); // Auto submit
                    return;
                }
                remainingSeconds--;
                
                const h = Math.floor(remainingSeconds / 3600).toString().padStart(2, '0');
                const m = Math.floor((remainingSeconds % 3600) / 60).toString().padStart(2, '0');
                const s = (remainingSeconds % 60).toString().padStart(2, '0');
                timerEl.textContent = `${h}:${m}:${s}`;
                
                if (remainingSeconds < 300) timerEl.style.color = 'red'; // Warning < 5 mins
            }, 1000);
        }

        // --- Rendering ---

        function renderPalette() {
            const palette = document.getElementById('palette');
            palette.innerHTML = '';
            questions.forEach((q, idx) => {
                const btn = document.createElement('button');
                btn.className = `q-btn ${idx === currentQIndex ? 'active' : ''}`;
                
                // Check if answered
                if (answers[q.id] && answers[q.id].selected_options.length > 0) {
                    btn.classList.add('answered');
                }
                
                btn.textContent = idx + 1;
                btn.onclick = () => {
                    saveCurrentAnswer(); // Save before moving
                    loadQuestion(idx);
                };
                palette.appendChild(btn);
            });
        }

        function loadQuestion(index) {
            currentQIndex = index;
            const q = questions[index];
            
            document.getElementById('q-number').textContent = `Question ${index + 1} of ${questions.length}`;
            document.getElementById('q-text').textContent = q.text;
            document.getElementById('q-marks').textContent = `${q.marks} Mark${q.marks > 1 ? 's' : ''}`;
            
            // Buttons state
            document.getElementById('btn-prev').disabled = index === 0;
            document.getElementById('btn-next').textContent = index === questions.length - 1 ? 'Finish' : 'Next';

            // Render Options
            const container = document.getElementById('options-container');
            container.innerHTML = '';

            const savedAns = answers[q.id] ? answers[q.id].selected_options : [];

            if (q.question_type === 'MCQ' || q.question_type === 'TRUE_FALSE') {
                q.options.forEach(opt => {
                    const isChecked = savedAns.includes(opt.id);
                    const inputType = 'radio'; // MCQ is single select usually, but let's stick to radio for now
                    
                    const wrapper = document.createElement('div');
                    wrapper.innerHTML = `
                        <input type="${inputType}" name="q_option" id="opt_${opt.id}" class="option-input" value="${opt.id}" ${isChecked ? 'checked' : ''} onchange="markAnswer(${q.id}, ${opt.id}, '${inputType}')">
                        <label for="opt_${opt.id}" class="option-label">
                            ${opt.text}
                        </label>
                    `;
                    container.appendChild(wrapper);
                });
            } else if (q.question_type === 'MSQ') {
                 q.options.forEach(opt => {
                    const isChecked = savedAns.includes(opt.id);
                    const wrapper = document.createElement('div');
                    wrapper.innerHTML = `
                        <input type="checkbox" name="q_option" id="opt_${opt.id}" class="option-input" value="${opt.id}" ${isChecked ? 'checked' : ''} onchange="markAnswer(${q.id}, ${opt.id}, 'checkbox')">
                        <label for="opt_${opt.id}" class="option-label">
                            ${opt.text}
                        </label>
                    `;
                    container.appendChild(wrapper);
                });
            } else {
                // Short/Long Answer
                const textVal = answers[q.id] ? answers[q.id].answer_text : '';
                container.innerHTML = `
                    <textarea class="form-control" rows="5" placeholder="Type your answer here..." oninput="markTextAnswer(${q.id}, this.value)">${textVal}</textarea>
                `;
            }

            renderPalette(); // Update active state
        }

        function navQuestion(direction) {
            const newIndex = currentQIndex + direction;
            if (newIndex >= 0 && newIndex < questions.length) {
                saveCurrentAnswer();
                loadQuestion(newIndex);
            } else if (newIndex === questions.length) {
                // Clicked Finish
                saveCurrentAnswer();
                confirmSubmit();
            }
        }

        // --- Answer Handling ---

        function markAnswer(qId, optId, type) {
            if (!answers[qId]) answers[qId] = { selected_options: [], answer_text: "" };
            
            if (type === 'radio') {
                answers[qId].selected_options = [optId];
            } else {
                // Checkbox toggle
                const idx = answers[qId].selected_options.indexOf(optId);
                if (idx > -1) answers[qId].selected_options.splice(idx, 1);
                else answers[qId].selected_options.push(optId);
            }
            isDirty = true;
            renderPalette(); // Update green status immediately
        }

        function markTextAnswer(qId, text) {
            if (!answers[qId]) answers[qId] = { selected_options: [], answer_text: "" };
            answers[qId].answer_text = text;
            isDirty = true;
        }

        async function saveCurrentAnswer() {
            if (!isDirty) return;
            
            const q = questions[currentQIndex];
            const ans = answers[q.id];
            
            if (!ans) return;

            const statusEl = document.getElementById('connection-status');
            statusEl.textContent = 'Saving...';
            statusEl.className = 'text-warning';

            try {
                await fetch(`${API_BASE}/save-answer/`, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        attempt_id: attemptId,
                        question_id: q.id,
                        selected_options: ans.selected_options,
                        answer_text: ans.answer_text
                    })
                });
                isDirty = false;
                statusEl.textContent = '● Connected (Saved)';
                statusEl.className = 'text-success';
            } catch (e) {
                console.error("Save failed", e);
                statusEl.textContent = '● Offline (Retrying...)';
                statusEl.className = 'text-danger';
            }
        }

        // --- Submission ---

        function confirmSubmit() {
            if (confirm("Are you sure you want to submit the exam? You cannot undo this action.")) {
                submitExam(false);
            }
        }

        async function submitExam(auto) {
            await saveCurrentAnswer(); // Final save
            
            try {
                await fetch(`${API_BASE}/submit/${attemptId}/`, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (auto) alert("Time is up! Your exam has been auto-submitted.");
                else alert("Exam submitted successfully!");
                
                window.location.href = "{% url 'student_dashboard' %}";
            } catch (e) {
                alert("Submission failed. Please check your connection.");
            }
        }

    </script>
</body>
</html>